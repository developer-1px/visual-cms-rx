# 바이브코딩을 위한 svelte-rx 핵심 컨셉

## 핵심 목표
- **바이브코딩을 쉽게 하기 위한 라이브러리**
- **느슨한 결합(loose coupling)을 강제**
- **수렴하는 코드(converging code) 작성 지원**

## 의미
이 라이브러리는 개발자가 코드를 작성할 때 자연스럽게 느슨한 결합을 유지하도록 하고, 
여러 부분이 하나의 목표로 수렴하는 형태의 코드를 쉽게 작성할 수 있도록 돕는 것이 목표다.

## 아키텍처 패턴: MVI (Model-View-Intent)
- Cycle.js 창시자가 만든 MVI 개념 적용
- **모든 것을 이벤트(액션)와 상태로 관리**
- **RxJS가 중간 역할을 담당**
- Intent(액션) → Model(상태) → View(UI) 순환 구조

## 기술 선택 이유
- **RxJS**: 강력한 연산자를 제공하지만 상태관리 전용 도구는 아님
- **Svelte 5 Rune**: 반응성은 개선되었지만 연산자가 강력하지 않음
- **svelte-rx**: 두 기술의 장점을 결합
  - RxJS의 강력한 연산자
  - Svelte 5의 개선된 반응성
  - 상태관리에 특화된 인터페이스

## 바이브 코딩의 문제점과 해결책
### 문제점
1. **데이터 관리의 불명확성**: 어디서 데이터가 관리되는지 알기 어려움
2. **데이터 흐름 추적의 어려움**: 데이터가 어떻게 흘러가는지 파악하기 힘듦
3. **코드가 수렴하지 못함**: 여러 부분이 하나로 모이지 않고 흩어짐

### svelte-rx의 해결책
- 모든 데이터를 이벤트와 상태로 명확히 정의
- RxJS 스트림으로 데이터 흐름을 추적 가능하게 만듦
- MVI 패턴으로 코드가 자연스럽게 수렴하도록 유도

## 상태 관리 구조
- **단일 루트 상태(Root State)**: Redux처럼 하나의 root state로 모든 상태 관리
- **명명된 스토어**: Pinia처럼 각 store는 고유한 이름을 가짐
- 장점:
  - 전체 상태를 한 곳에서 파악 가능
  - 각 스토어를 이름으로 쉽게 접근
  - 디버깅과 상태 추적이 용이

## API 예시

### 액션 등록
```typescript
const _선택하기 = action<number>("_선택하기")
```
- Redux의 action creator와 유사
- 타입 안전성 보장 (제네릭으로 페이로드 타입 지정)
- 액션 이름으로 디버깅 용이

### 액션 디스패치
```typescript
dispatch(_선택하기(1))
```
- 액션을 실행하여 이벤트 발행
- 내부적으로 RxJS Subject 활용 (ReplaySubject 고려)
- 모든 구독자에게 이벤트 전달
- **ReplaySubject 사용 검토**: reducer가 늦게 실행되어도 이전 액션 누락 방지

### 리듀서
```typescript
const value = reducer("path/to", 0, on => {
  on(_선택하기).pipe(...)
})
```
- derived/computed와 유사하지만 액션 기반
- 특정 경로의 상태 변화를 한 곳에서 관리
- RxJS 연산자로 복잡한 로직 처리 가능
- 모든 상태 변화가 명시적으로 추적됨
- 초기값 설정 가능 (두 번째 파라미터)

## 설계 결정사항
- **액션 네이밍**: `_`로 시작하는 컨벤션 (자동완성 편의성)
- **경로 구조**: root부터 중첩된 객체 경로 (향후 proxy + TypeScript 방식 고려)
- **전역 상태 관리**: 모든 구독은 항상 활성화 (자동 구독 해제 없음)
- **전역 액션**: 모든 액션은 전역 스코프 (필요시 filter로 제한 가능)

## 디버깅 기능
- **액션 로깅**: 모든 액션과 페이로드 자동 기록
- **상태 히스토리**: 상태 변화 과정 추적
- **디버그 패널**: 
  - 액션 재실행
  - 상태 직접 수정
  - 타임 트래블 디버깅
- Redux DevTools와 유사한 개발자 경험