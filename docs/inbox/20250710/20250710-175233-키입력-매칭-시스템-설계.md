# 키입력 매칭 시스템 설계 보고서

> 키입력 시스템을 만들거야 event.key && key.meta 이런식으로 하지 않고 "meta+a" 이런식으로 매칭할 수 있는 키입력 시스템 특히 조건에 따라서 분기할 수 있는 매칭 시스템을 만들고자해.

## 현재 상황 분석

### 기존 방식의 문제점
- `event.key && key.meta` 방식은 복잡한 조건문으로 가독성이 떨어짐
- 키 조합이 늘어날수록 코드가 기하급수적으로 복잡해짐
- 동적 키 바인딩이 어려움
- 조건부 분기나 우선순위 처리가 복잡함

### 목표 요구사항
1. **선언적 키 패턴**: `"meta+a"` 형태의 직관적 표현
2. **조건부 분기**: 상황에 따른 다른 액션 실행
3. **성능**: 실시간 키 매칭 최적화
4. **확장성**: 새로운 키 조합과 조건 추가 용이성

## 제안 설계

### 1. 키 패턴 문법

```typescript
// 기본 패턴
"meta+a"           // ⌘+A
"ctrl+shift+s"     // Ctrl+Shift+S
"escape"           // ESC
"space"            // Space

// 시퀀스 패턴
"meta+a,b"         // ⌘+A 후 B
"g,g"              // G 두 번 (vim 스타일)

// 대안 패턴
"meta+a|ctrl+a"    // ⌘+A 또는 Ctrl+A
```

### 2. 조건부 분기 시스템

```typescript
interface KeyBinding {
  pattern: string;
  action: string | KeyAction[];
  when?: string | ((context: KeyContext) => boolean);
  priority?: number;
}

interface KeyAction {
  when: string | ((context: KeyContext) => boolean);
  action: string;
}

// 사용 예시
const bindings: KeyBinding[] = [
  {
    pattern: "meta+a",
    action: [
      { when: "editor.focused", action: "selectAll" },
      { when: "list.focused", action: "selectAllItems" },
      { when: "default", action: "globalSelectAll" }
    ]
  },
  {
    pattern: "escape",
    action: "cancel",
    when: "modal.open"
  }
];
```

### 3. 컨텍스트 시스템

```typescript
interface KeyContext {
  focused: string;          // 현재 포커스된 요소
  mode: string;            // 현재 모드 (edit, select, etc.)
  selection: boolean;      // 선택 영역 존재 여부
  modifiers: string[];     // 현재 누른 modifier 키들
  custom: Record<string, any>; // 커스텀 컨텍스트
}
```

### 4. 성능 최적화 구조

```typescript
// 트리 구조를 통한 빠른 매칭
interface KeyNode {
  key: string;
  modifiers: Set<string>;
  actions: KeyAction[];
  children: Map<string, KeyNode>;
  isTerminal: boolean;
}

// 해시맵을 통한 빠른 조건 평가
interface ConditionCache {
  [condition: string]: boolean;
}
```

## 구현 전략

### Phase 1: 기본 패턴 매칭
- 단일 키 조합 파싱 (`"meta+a"`)
- 기본 modifier 지원 (meta, ctrl, shift, alt)
- 단순 액션 디스패치

### Phase 2: 조건부 분기
- 컨텍스트 시스템 구현
- when 조건 평가 엔진
- 우선순위 기반 매칭

### Phase 3: 고급 기능
- 시퀀스 키 지원
- 대안 패턴 지원
- 동적 키 바인딩 API

### Phase 4: 성능 최적화
- 트리 구조 매칭 엔진
- 조건 캐싱 시스템
- 메모리 효율성 개선

## 핵심 설계 결정사항

### 1. 키 표현 방식
- **선택**: `"meta+a"` 형태 (소문자, + 구분자)
- **이유**: 직관적이고 파싱이 쉬움
- **대안 고려**: `"cmd+a"`, `"⌘+a"` 형태도 별칭으로 지원

### 2. 조건 평가 방식
- **선택**: 문자열 기반 조건 + 함수 지원
- **이유**: 선언적이면서 유연성 확보
- **예시**: `"editor.focused"`, `"!modal.open"`

### 3. 우선순위 전략
- **선택**: 명시적 우선순위 + 구체성 기반
- **이유**: 예측 가능한 동작 보장
- **규칙**: 구체적 조건 > 일반적 조건

### 4. 성능 목표
- **목표**: 키 입력부터 액션 실행까지 < 1ms
- **전략**: 트리 구조 + 조건 캐싱
- **측정**: 평균 매칭 시간 벤치마크

## 예상 사용 시나리오

### HTML 에디터에서의 활용
```typescript
const editorBindings = [
  {
    pattern: "meta+z",
    action: "undo",
    when: "editor.canUndo"
  },
  {
    pattern: "meta+y",
    action: "redo", 
    when: "editor.canRedo"
  },
  {
    pattern: "delete",
    action: [
      { when: "selection.hasElements", action: "deleteElements" },
      { when: "selection.hasText", action: "deleteText" }
    ]
  }
];
```

### 선택 모드에서의 활용
```typescript
const selectionBindings = [
  {
    pattern: "escape",
    action: "clearSelection",
    when: "selection.active"
  },
  {
    pattern: "meta+a",
    action: "selectAll",
    when: "editor.focused"
  }
];
```

## 다음 단계

1. **프로토타입 구현**: 기본 패턴 매칭 엔진
2. **테스트 케이스 작성**: 다양한 키 조합 시나리오
3. **성능 벤치마크**: 매칭 속도 측정
4. **API 설계**: 사용자 친화적 인터페이스
5. **통합 테스트**: 실제 에디터와 연동

## 결론

제안된 키입력 매칭 시스템은:
- **선언적**: 직관적인 패턴 표현
- **조건부**: 상황별 다른 액션 지원
- **성능**: 빠른 실시간 매칭
- **확장성**: 새로운 요구사항 대응 용이

이 시스템을 통해 HTML 에디터의 키보드 인터랙션을 효율적으로 관리할 수 있을 것으로 예상됩니다.