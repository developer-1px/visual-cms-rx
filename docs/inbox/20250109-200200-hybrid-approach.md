# 하이브리드 접근법

## 두 가지 사용 패턴

### 1. 단순 매핑 (90% 케이스)
```typescript
// pipe 없이 바로 매퍼 함수 전달
on(_증가하기, (state, amount) => state + amount)
on(_감소하기, (state, amount) => state - amount)
on(_리셋하기, () => 0)
```

### 2. 복잡한 RxJS 연산 (10% 케이스)
```typescript
// pipe가 필요할 때는 기존처럼
on(_검색하기).pipe(
  debounceTime(300),
  distinctUntilChanged(),
  map(([state, query]) => ({ ...state, searchQuery: query }))
)

// 또는 조건부 처리
on(_증가하기).pipe(
  filter(([state, amount]) => amount > 0),
  map(([state, amount]) => state + amount)
)
```

## 구현 아이디어
```typescript
// on 함수가 두 가지 시그니처 지원
interface OnFunction<TState> {
  // 단순 매핑
  <P>(action: Action<P>, mapper: (state: TState, payload: P) => TState): void;
  
  // 복잡한 연산을 위한 pipe
  <P>(action: Action<P>): PipeableStream<TState, P>;
}
```

## 장점
- 대부분의 경우 간결하게 작성
- 필요할 때만 pipe 사용
- 점진적 복잡도
- RxJS의 힘은 그대로 유지