# EditMode 텍스트 편집 기능 구현 계획

> editMode가 되면 모든 text span들은 contenteditable="plaintext-only"모드가 되어서 텍스트 수정이 가능하도록 만들거야. 이떄 주의 해야하는 점은 svelte의 반응성과 contenteditble편집간의 업데이트가 반복되어 focus를 잃는등 편집이 잘 안되는건데 별도의 데이터를 마련해서 편집중에는 원래 모델의 데이터를 반영하지 않도록 하고 blur시 실제 모델에 반영이 되도록 하는게 중요해. 그리고 editmode인 경우에는 selection UI를 다르게 해서 알수 있게 해주자. 그리고 이때에는 다른 text를 클릭하면 선택이 아니라 바로 해당 글자에 위치에 커서를 위치시켜줘야 해

## 현재 상황 분석

### 기존 구조
- `modeStore.ts`: view/edit 모드 관리
- `HtmlRenderer.svelte`: 텍스트 노드를 span으로 렌더링
- `SelectionOverlay.svelte`: 선택된 요소 하이라이트
- `EditOverlay.svelte`: 편집 모드 오버레이 (현재 미구현)

### 주요 과제
1. **Svelte 반응성과 contenteditable 충돌 문제**
   - contenteditable 요소가 리렌더링되면 focus와 커서 위치를 잃음
   - 입력 중에 모델 업데이트가 발생하면 편집이 중단됨

2. **편집 중 임시 상태 관리**
   - 편집 중인 텍스트를 별도로 관리
   - blur 시점에만 실제 모델에 반영

3. **EditMode UI/UX**
   - 편집 가능한 텍스트 시각적 구분
   - 클릭 시 즉시 커서 위치 지정

## 구현 계획

### 1단계: EditMode 상태 관리 확장
```typescript
// modeStore.ts 확장
- editingNodeId: 현재 편집 중인 노드 ID
- tempTextContent: Map<nodeId, string> 편집 중 임시 텍스트
```

### 2단계: EditableText 컴포넌트 분리
```svelte
// 새로운 파일: EditableText.svelte
<script lang="ts">
  import type { HtmlNode } from '../entities/editor/types';
  
  export let node: HtmlNode;
  export let isEditMode: boolean;
  
  // 편집 상태 관리
  let isEditing = false;
  let tempContent = node.textContent;
  
  function handleFocus() { ... }
  function handleBlur() { ... }
  function handleInput(e: Event) { ... }
  function handleClick(e: MouseEvent) { ... }
</script>

{#if isEditMode}
  <span
    contenteditable="plaintext-only"
    class="editable-text"
    class:editing={isEditing}
    data-node-id={node.id}
    on:focus={handleFocus}
    on:blur={handleBlur}
    on:input={handleInput}
    on:click={handleClick}
  >
    {tempContent}
  </span>
{:else}
  <span class="text-node" data-node-id={node.id}>
    {node.textContent}
  </span>
{/if}
```

### 3단계: HtmlRenderer에서 EditableText 사용
```svelte
// HtmlRenderer.svelte 수정
{#if node.type === 'text'}
  <EditableText {node} {isEditMode} />
{:else if node.type === 'element'}
  <!-- 기존 element 렌더링 -->
{/if}
```

### 4단계: 이벤트 핸들러 구현
1. **focus**: 편집 시작, editingNodeId 설정
2. **input**: tempTextContent에만 업데이트
3. **blur**: 실제 모델에 반영, 임시 데이터 클리어
4. **click**: 커서 위치 계산 및 설정

### 5단계: EditMode UI 스타일
```css
/* 편집 모드 텍스트 스타일 */
.edit-mode [contenteditable] {
  outline: 1px dashed #999;
  cursor: text;
}

.edit-mode [contenteditable]:focus {
  outline: 2px solid #4A90E2;
  background: rgba(74, 144, 226, 0.05);
}
```

### 6단계: 선택 동작 분기
- ViewMode: 기존 텍스트 선택 동작
- EditMode: 클릭 시 즉시 편집 모드 진입

## 기술적 고려사항

### 1. Focus 유지 전략
```typescript
// 커서 위치 저장 및 복원
function saveCursorPosition() {
  const selection = window.getSelection();
  return {
    anchorOffset: selection.anchorOffset,
    focusOffset: selection.focusOffset
  };
}

function restoreCursorPosition(element, position) {
  const selection = window.getSelection();
  const range = document.createRange();
  range.setStart(element.firstChild, position.anchorOffset);
  range.setEnd(element.firstChild, position.focusOffset);
  selection.removeAllRanges();
  selection.addRange(range);
}
```

### 2. 텍스트 업데이트 액션
```typescript
// 새로운 액션 추가
export const updateNodeText = action<{nodeId: string, text: string}>('updateNodeText');
```

### 3. 편집 중 상태 격리
- 편집 중인 노드는 tempTextContent 사용
- 다른 노드 업데이트 시에도 편집 중인 노드는 영향받지 않음

## 예상 문제점 및 해결책

1. **다중 노드 동시 편집**
   - 해결: 한 번에 하나의 노드만 편집 가능하도록 제한

2. **Undo/Redo 통합**
   - 해결: blur 시점에 히스토리 스택에 추가

3. **특수 문자 처리**
   - 해결: plaintext-only 사용으로 HTML 삽입 방지

## 테스트 시나리오

1. 텍스트 클릭 → 즉시 편집 가능
2. 편집 중 다른 노드 클릭 → 이전 편집 저장 후 새 노드 편집
3. ESC 키 → 편집 취소
4. Enter 키 → 편집 완료
5. 편집 중 외부 클릭 → 편집 저장

## 구현 우선순위

1. **필수 기능** (P0)
   - EditableText 컴포넌트 생성
   - contenteditable 토글
   - focus/blur 이벤트 처리
   - 임시 데이터 관리

2. **핵심 UX** (P1)
   - 커서 위치 지정
   - 편집 모드 시각적 피드백

3. **추가 기능** (P2)
   - 키보드 단축키
   - 다중 선택 편집

## 컴포넌트 분리의 장점

1. **관심사 분리**: 텍스트 편집 로직이 독립적으로 관리됨
2. **재사용성**: 다른 곳에서도 편집 가능한 텍스트 사용 가능
3. **테스트 용이성**: 텍스트 편집 기능만 독립적으로 테스트 가능
4. **유지보수성**: 편집 관련 코드가 한 곳에 집중됨